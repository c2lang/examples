module event;
import stdlib;
import unistd;
import sys_time;
import stdio local;

public func u64 current_time() {
    sys_time.timeval tv;
    sys_time.gettimeofday(&tv, nil);
    u64 now64 = cast<u64>(tv.tv_sec);
    now64 *= 1000000;
    now64 += tv.tv_usec;
    return now64;
}

public type Base struct {
    u32 running_loop;
    u32 loop_break;
    u8 return_value;
    Timer* timers;
} @(opaque)

public func Base* Base.create() {
    Base* base = stdlib.malloc(sizeof(Base));
    return base;
}

public func void Base.free(Base* base) {
    stdlib.free(base);
}

public func u8 Base.mainloop(Base* base) {
    base.return_value = 0;
    base.running_loop = 1;
    while (!base.loop_break) {
        base.internal_loop();
    }
    base.running_loop = 0;
    return base.return_value;
}

public func void Base.loopbreak(Base* base, u8 return_value) {
    base.return_value = return_value;
    base.loop_break = 1;
    //if (base->running_loop) base.sendcmd(stop_cmd);
}

func void Base.fire_timer(Base* base) {
    Timer* timer = base.timers;
    base.timers = timer.next;
    timer.next = nil;
    if (timer.flags &= TIMER_PERSIST) {
        timer.timeout += timer.interval_usec;
        timer.add_internal();
    } else {
        timer.flags &= ~TIMER_PENDING;
    }
    timer.handler(timer.handler_arg);
}

func void Base.internal_loop(Base* base) {
    if (base.timers) {
        Timer* timer = base.timers;
        u64 now = current_time();
        if (now >= timer.timeout) {
            base.fire_timer();
            return;
        } else {
            //u64 delay = timer.timeout - now;
        }
    }
}

