module sukodu;

import stdio local;
import color;
import string local;


type Field struct {
    u8 value;       // !0 if known
    u16 options;    // bitbise if still valid TODO 0 is option, 1 is crossed out
}

type Board struct {
    Field[9*9] fields;
    bool inSetup;
    u32 todo;
}

const i8[] SquareOffsets = {
       1,   2,   9,  10,  11, 18, 19, 20 , // top left
      -1,   1,   8,   9,  10, 17, 18, 19 , // top middle
      -2,  -1,   7,   8,   9, 16, 17, 18 , // top right
      -9,  -8,  -7,   1,   2,  9, 10, 11 , // middle left
     -10,  -9,  -8,  -1,   1,  8,  9, 10 , // middle
     -11, -10,  -9,  -2,  -1,  7,  8,  9 , // middle right
     -18, -17, -16,  -9,  -8, -7,  1,  2 , // bottom left
     -19, -18, -17, -10,  -9, -8, -1,  1 , // bottom middle
     -20, -19, -18, -11, -10, -9, -2, -1 , // bottom right
}

func void Board.set(Board* board, u8 x, u8 y, u8 value) {
    if (!board.inSetup) printf("set %u,%u -> %u\n", y, x, value);
    u32 idx = 9*y + x;
    board.fields[idx].value = value;
    board.fields[idx].options = 0;
    board.todo--;
    //board.fields[idx].options = (1<<value);

    u32 clear = ~(1<<value);
    // clear row
    for (u32 i=0; i<9; ++i) {
        if (i==x) continue;
        board.fields[9*y + i].options &= clear;
    }
    // clear column
    for (u32 i=0; i<9; ++i) {
        if (i==y) continue;
        board.fields[9*i + x].options &= clear;
    }
    // clear square
    i32 offs = x%3 + (y%3)*3;
    //printf("OFFS %d\n", offs);
    for (u32 i=0; i<8; i++) {
        //printf("  offset %d -> \n", SquareOffsets[offs*8 + i]);
        board.fields[idx + SquareOffsets[offs*8 + i]].options &= clear;
    }
    if (!board.inSetup) board.print(false, x, y);
}

func void Board.init(Board* board) {
    memset(board, 0, sizeof(Board));
    for (u32 y=0; y<9; y++) {
        for (u32 x=0; x<9; x++) {
            u32 idx = 9*y + x;
            board.fields[idx].options = 0x3FE;  // set bits 1-9
        }
    }
    board.todo = 9*9;
}

func void Board.print(const Board* board, bool showOptions, u8 xx, u8 yy) {
    char[2048] buffer;
    memset(buffer, 0, sizeof(buffer));
    char* cp = buffer;
    cp += sprintf(cp, "-------------------------\n");
    for (u32 y=0; y<9; y++) {
        *cp++ = '|';
        for (u32 x=0; x<9; x++) {
            u32 idx = 9*y + x;
            const Field* f = &board.fields[idx];
            if (f.value) {
                const char* col = color.Green;
                if (x == xx && y == yy) col = color.Byellow;
                cp += sprintf(cp, " %s%u%s", col, f.value, color.Normal);
            } else {
                cp += sprintf(cp, "  ");
            }
            if (x % 3 == 2) {
                *cp++ = ' ';
                *cp++ = '|';
            }
        }
        *cp++ = '\n';
        if (y % 3 == 2) cp += sprintf(cp, "-------------------------\n");
    }
    *cp = 0;
    puts(buffer);
    if (showOptions && board.todo != 0) board.printOptions();
}

func void Board.printOptions(const Board* board) {
    u32 height = 9 * 4 + 1;
    u32 width =  9 * 8 + 2;
    char[width * height + 1] buffer;
    memset(buffer, ' ', sizeof(buffer));
    buffer[width * height] = 0;
    // horizontal + vertical lines
    for (u32 y=0; y<height; y++) {
        char* line = &buffer[y*width];
        if (y % 12 == 0) for (u32 x=0; x<width-1; x++) line[x] = '=';
        else if (y % 4 == 0) for (u32 x=0; x<width-1; x++) line[x] = '-';
        else {
            for (u32 x=0; x<width-1; x++) {
                if (x % 8 == 0) line[x] = '|';
            }
        }
        line[width-1] = '\n';
    }

    // option values
    for (u8 y=0; y<9; y++) {
        for (u8 x=0; x<9; x++) {
            const Field* f = &board.fields[y*9 + x];
            u32 offset = (1 + 4 * y) * width + (1 + 8 * x);
            u8* square = &buffer[offset];
            for (u8 o=1; o<10; o++) {
                if (f.options & (1<<o)) {
                    u32 h = (o-1) % 3;
                    u32 w = (o-1) / 3;
                    square[(width * w) + (2 * h) + 1] = o + '0';
                }
            }
        }
    }

    puts(buffer);
}

func void Board.setup(Board* board, Setup* setup, u32 size) {
    board.inSetup = true;
    for (u32 i=0; i<size; i++) {
        Setup* s = &setup[i];
        board.set(s.x, s.y, s.value);
    }
    board.inSetup = false;
    printf("setup (%u given)\n", size);
    board.print(false, 10, 0);
}

func bool Board.checkFields(Board* board) {
    //printf("checking fields\n");
    bool found = false;
    for (u8 y=0; y<9; y++) {
        for (u8 x=0; x<9; x++) {
            Field* f = &board.fields[y*9 + x];
            // check for single bit
            u16 options = f.options;
            switch (options) {
            case 2:
                board.set(x, y, 1);
                found = true;
                break;
            case 4:
                board.set(x, y, 2);
                found = true;
                break;
            case 8:
                board.set(x, y, 3);
                found = true;
                break;
            case 16:
                board.set(x, y, 4);
                found = true;
                break;
            case 32:
                board.set(x, y, 5);
                found = true;
                break;
            case 64:
                board.set(x, y, 6);
                found = true;
                break;
            case 128:
                board.set(x, y, 7);
                found = true;
                break;
            case 256:
                board.set(x, y, 8);
                found = true;
                break;
            case 512:
                board.set(x, y, 9);
                found = true;
                break;
            default:
                break;
            }
        }
    }
    return found;
}

func bool Board.checkRow(Board* board, u8 row) {
    //printf("checking row %u\n", row);
    bool found = false;
    u8[10] count = { 0 }
    u8[10] pos = { 0 }
    for (u8 x=0; x<9; x++) {
        u32 idx = 9*row + x;
        const Field* f = &board.fields[idx];
        for (u32 o=1; o<10; o++) {
            if ((f.options >> o) & 1) {
                count[o]++;
                pos[o] = x;
            }
        }
    }
    for (u8 o=1; o<10; o++) {
        //printf("%u = %u [%u]\n", o, count[o], pos[o]);
        if (count[o] == 1) {
            board.set(pos[o], row, o);
            found = true;
        }
    }

    return found;
}

func bool Board.checkColumn(Board* board, u8 col) {
    //printf("checking column %u\n", col);
    bool found = false;
    u8[10] count = { 0 }
    u8[10] pos = { 0 }
    for (u8 y=0; y<9; y++) {
        u32 idx = 9*y + col;
        const Field* f = &board.fields[idx];
        for (u32 o=1; o<10; o++) {
            if ((f.options >> o) & 1) {
                count[o]++;
                pos[o] = y;
            }
        }
    }
    for (u8 o=1; o<10; o++) {
        //printf("COL %u = %u [%u]\n", o, count[o], pos[o]);
        if (count[o] == 1) {
            board.set(col, pos[o], o);
            found = true;
        }
    }

    return found;
}

func void Board.solve(Board* board) {
    printf("solving Sudoku\n");
    u32 loops = 0;
    while (1) {
        bool found = false;
        printf("checking rows (%u todo)\n", board.todo);
        for (u8 i=0; i<9; i++) {
            found |= board.checkRow(i);
        }
        printf("checking columns (%u todo)\n", board.todo);
        for (u8 i=0; i<9; i++) {
            found |= board.checkColumn(i);
        }
        printf("checking columns (%u todo)\n", board.todo);
        found |= board.checkFields();
        loops++;
        if (!found) break;
        if (board.todo == 0) break;
    }
    printf("%u loops\n", loops);
}

type Setup struct {
    u8 y;
    u8 x;
    u8 value;
} @(packed)

#if 1
Setup[] setup_pg4 = {
    { 0, 5, 6 }, { 0, 8, 3 },
    { 1, 0, 2 }, { 1, 2, 5 }, { 1, 5, 8 },
    { 2, 2, 8 }, { 2, 5, 4 }, { 2, 6, 7 },
    { 3, 1, 7 }, { 3, 8, 8 },
    { 4, 3, 1 }, { 4, 4, 9 }, { 4, 6, 6 },
    { 5, 1, 6 }, { 5, 6, 9 },
    { 6, 6, 3 }, { 6, 8, 5 },
    { 7, 1, 2 }, { 7, 3, 3 }, { 7, 5, 9 }, { 7, 6, 8 }, { 7, 7, 6 }, { 7, 8, 1 },
    { 8, 0, 7 }, { 8, 5, 1 }, { 8, 7, 2 },
}
Setup[] setup_pg5 = {
    { 0, 2, 5 }, { 0, 8, 2 },
    { 1, 1, 9 },
    { 2, 0, 2 }, { 2, 4, 4 }, { 2, 6, 5 }, { 2, 8, 7 },
    { 3, 2, 8 }, { 3, 4, 6 }, { 3, 5, 7 }, { 3, 8, 3 },
    { 4, 0, 5 }, { 4, 4, 8 }, { 4, 6, 4 },
    { 5, 0, 1 }, { 5, 5, 9 }, { 5, 7, 2 },
    { 6, 1, 5 }, { 6, 3, 6 }, { 6, 4, 9 }, { 6, 7, 4 },
    { 7, 2, 1 }, { 7, 4, 2 },
    { 8, 7, 8 }, { 8, 8, 9 },
}
#else
Setup[] setup_pg4 = {
    { 2, 2, 8 },
}
#endif

public func i32 main() {
    Board board;
    board.init();

    //board.setup(setup_pg4, elemsof(setup_pg4));
    board.setup(setup_pg5, elemsof(setup_pg5));

    board.solve();
    board.print(true, 10, 0);
    return 0;
}

