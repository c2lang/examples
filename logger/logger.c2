module logger;

import color;
import stdarg local;
import string local;
import stdio local;
import stdlib local;
import sys_time local;
import unistd;
import time;

// TODO get from backend
bool useColor = true;
bool relativeTimes = true;
uint64 startTime;

public func void create(bool useColor_, bool relTimes) {
    useColor = useColor_;
    relativeTimes = relTimes;
    startTime = current_time();
}

public type Level enum uint8 {
    FATAL = 0,
    ERROR,
    WARN,
    INFO,
    DEBUG,
}

func const char* level2str(Level lvl) {
    switch (lvl) {
    case FATAL: return "FATAL";
    case ERROR: return "ERROR";
    case WARN:  return "WARN ";
    case INFO:  return "INFO ";
    case DEBUG: return "DEBUG";
    }
    return nil;
}

func uint64 current_time() {
   timeval tv;
   gettimeofday(&tv, nil);
   uint64 tv64 = cast<uint64>(tv.tv_sec);
   tv64 *= 1000000;
   tv64 += tv.tv_usec;
   return tv64;
}

public type Log struct {
    char[16] name;
    Level level;
}

public func void Log.init(Log* log, const char* name_, Level lvl) {
    strcpy(log.name, name_);
    log.level = lvl;
}

public func void Log.setLevel(Log* log, Level lvl) {
    log.level = lvl;
}

public func void Log.debug(Log* log, const char* format, ...) {
    if (DEBUG > log.level) return;
    va_list args;
    va_start(args, format);
    log.internal(DEBUG, color.blue, format, args);
    va_end(args);
}

public func void Log.info(Log* log, const char* format, ...) {
    if (INFO > log.level) return;
    va_list args;
    va_start(args, format);
    log.internal(INFO, color.white, format, args);
    va_end(args);
}

public func void Log.warn(Log* log, const char* format, ...) {
    if (WARN > log.level) return;
    va_list args;
    va_start(args, format);
    log.internal(WARN, color.yellow, format, args);
    va_end(args);
}

public func void Log.error(Log* log, const char* format, ...) {
    if (ERROR > log.level) return;
    va_list args;
    va_start(args, format);
    log.internal(ERROR, color.red, format, args);
    va_end(args);
}

public func void Log.fatal(Log* log, const char* format, ...) {
    va_list args;
    va_start(args, format);
    log.internal(FATAL, color.red, format, args);
    va_end(args);
    exit(EXIT_FAILURE);
}

func void Log.internal(Log* log, Level level, const char* color_, const char* format, va_list args) {
    char[256] buffer;
    char* cp = buffer;

    if (useColor) cp += sprintf(cp, "%s", color_);
    *cp++ = '[';
    if (relativeTimes) {
        uint64 now = current_time();
        now -= startTime;
        uint64 subsec = now % 1000000;
        cp += sprintf(cp, "%04ld.%06ld", now / 1000000, subsec);
    } else {
        timeval tv;
        gettimeofday(&tv, nil);
        time_t now = tv.tv_sec;
        time.tm* now2 = time.localtime(&now);
        cp += sprintf(cp, "%02d/%02d/%02d %02d:%02d:%02d.%0.lu",
            now2.tm_year % 100, now2.tm_mon + 1, now2.tm_mday,
            now2.tm_hour, now2.tm_min, now2.tm_sec, tv.tv_usec / 1000);
    }
    *cp++ = ']';
    cp += sprintf(cp, " %s %s: ", level2str(level), log.name);
    cp += vsprintf(cp, format, args);
    if (useColor) cp += sprintf(cp, "%s", color.normal);
    *cp++ = '\n';
    *cp = 0;
    printf("%s", buffer);
    // TODO replace with write() to backend
}

